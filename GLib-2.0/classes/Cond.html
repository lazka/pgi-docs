

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>
    GLib.Cond -
    
      Structures -
    
    GLib 2.0
  </title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/css/pgi.css" type="text/css" />
  

  
  <script type="text/javascript">

    function openSidebar(element) {
        window.location.href = element.href + location.hash;
        return false;
    }

    function inIframe() {
        try {
            return window.self !== window.top;
        } catch (e) {
            return true;
        }
    }

    function onLoaded() {
        if(!inIframe()) {
            var icons = document.getElementsByClassName('open-sidebar');

            for (var i = 0; i < icons.length; i ++) {
                icons[i].style.display = 'table-cell';
            }
        }
    }

    document.addEventListener('DOMContentLoaded', onLoaded, false);

  </script>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GLib 2.0 Python API Docs" href="../index.html"/>
        <link rel="up" title="Structures" href="../structs.html"/>
        <link rel="next" title="GLib.Data" href="Data.html"/>
        <link rel="prev" title="GLib.Checksum" href="Checksum.html"/> 
</head>

<body class="wy-body-for-nav" role="document">

<div class="non-fixed-bar">
<table class="navigation" summary="Navigation header" cellpadding="2" cellspacing="10" width="100%"><tbody><tr valign="middle">

<td class="open-sidebar" style="display:none"><a href="../../index.html#GLib-2.0/classes/Cond.html" onclick="return openSidebar(this);"><i class="fa fa-search"></i></a></td>

<td class="shortcuts" align="left" width="100%">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">GLib 2.0</a> &raquo;</li>
      
          <li><a href="../structs.html">Structures</a> &raquo;</li>
      
    <li>GLib.Cond</li>
  </ul>
</td>
<td><a accesskey="h" href="../index.html"><i class="fa fa-home"></i></a></td>


<td><a accesskey="u" href="../structs.html"><i class="fa fa-chevron-up"></i></a></td>



<td><a accesskey="p" href="Checksum.html"><i class="fa fa-chevron-left"></i></a></td>



<td><a accesskey="n" href="Data.html"><i class="fa fa-chevron-right"></i></a></td>


</tr></tbody>
</table>

<div class="local-toc">
    <ul>
<li><a class="reference internal" href="#">GLib.Cond</a><ul>
<li><a class="reference internal" href="#fields">Fields</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
<li><a class="reference internal" href="#details">Details</a></li>
</ul>
</li>
</ul>

</div>
</div>

<div class="fixed-bar">
  <table class="navigation" summary="Navigation header" cellpadding="2" cellspacing="10" width="100%"><tbody><tr valign="middle">

<td class="open-sidebar" style="display:none"><a href="../../index.html#GLib-2.0/classes/Cond.html" onclick="return openSidebar(this);"><i class="fa fa-search"></i></a></td>

<td class="shortcuts" align="left" width="100%">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">GLib 2.0</a> &raquo;</li>
      
          <li><a href="../structs.html">Structures</a> &raquo;</li>
      
    <li>GLib.Cond</li>
  </ul>
</td>
<td><a accesskey="h" href="../index.html"><i class="fa fa-home"></i></a></td>


<td><a accesskey="u" href="../structs.html"><i class="fa fa-chevron-up"></i></a></td>



<td><a accesskey="p" href="Checksum.html"><i class="fa fa-chevron-left"></i></a></td>



<td><a accesskey="n" href="Data.html"><i class="fa fa-chevron-right"></i></a></td>


</tr></tbody>
</table>

<div class="local-toc">
    <ul>
<li><a class="reference internal" href="#">GLib.Cond</a><ul>
<li><a class="reference internal" href="#fields">Fields</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
<li><a class="reference internal" href="#details">Details</a></li>
</ul>
</li>
</ul>

</div>
</div>

  <div class="wy-grid-for-nav">

    

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="main">
            
  <div class="section" id="glib-cond">
<h1>GLib.Cond<a class="headerlink" href="#glib-cond" title="Permalink to this headline">¶</a></h1>
<div class="section" id="fields">
<span id="glib-cond-fields"></span><h2>Fields<a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="16%" />
<col width="1%" />
<col width="1%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Access</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>i</td>
<td>[<a class="reference external" href="http://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>]</td>
<td>r</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>p</td>
<td><a class="reference external" href="http://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">object</span></code></a></td>
<td>r</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="methods">
<span id="glib-cond-methods"></span><h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.broadcast" title="GLib.Cond.broadcast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code></a> ()</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.clear" title="GLib.Cond.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a> ()</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.init" title="GLib.Cond.init"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init</span></code></a> ()</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.signal" title="GLib.Cond.signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal</span></code></a> ()</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a> (mutex)</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><a class="reference internal" href="#GLib.Cond.wait_until" title="GLib.Cond.wait_until"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_until</span></code></a> (mutex, end_time)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="details">
<h2>Details<a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="GLib.Cond">
<em class="property">class </em><code class="descclassname">GLib.</code><code class="descname">Cond</code><a class="headerlink" href="#GLib.Cond" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> struct is an opaque data structure that represents a
condition. Threads can block on a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> if they find a certain
condition to be false. If other threads change the state of this
condition they signal the <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a>, and that causes the waiting
threads to be woken up.</p>
<p>Consider the following example of a shared variable.  One or more
threads can wait for data to be published to the variable and when
another thread publishes the data, it can signal one of the waiting
threads to wake up to collect the data.</p>
<p>Here is an example for using <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> to block a thread until a condition
is satisfied:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gpointer</span><span class="w"> </span><span class="n">current_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="n">GMutex</span><span class="w"> </span><span class="n">data_mutex</span><span class="p">;</span><span class="w"></span>
<span class="n">GCond</span><span class="w"> </span><span class="n">data_cond</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"></span>
<span class="nf">push_data</span><span class="w"> </span><span class="p">(</span><span class="n">gpointer</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">g_mutex_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">current_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">g_cond_signal</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_cond</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">g_mutex_unlock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">gpointer</span><span class="w"></span>
<span class="nf">pop_data</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">gpointer</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">g_mutex_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">current_data</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">g_cond_wait</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_cond</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">current_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">g_mutex_unlock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Whenever a thread calls pop_data() now, it will wait until
current_data is non-<a class="reference external" href="http://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, i.e. until some other thread
has called push_data().</p>
<p>The example shows that use of a condition variable must always be
paired with a mutex.  Without the use of a mutex, there would be a
race between the check of <cite>current_data</cite> by the while loop in
pop_data() and waiting. Specifically, another thread could set
<cite>current_data</cite> after the check, and signal the cond (with nobody
waiting on it) before the first thread goes to sleep. <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> is
specifically useful for its ability to release the mutex and go
to sleep atomically.</p>
<p>It is also important to use the <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() and <a class="reference internal" href="#GLib.Cond.wait_until" title="GLib.Cond.wait_until"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait_until</span></code></a>()
functions only inside a loop which checks for the condition to be
true.  See <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() for an explanation of why the condition may
not be true even after it returns.</p>
<p>If a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call <a class="reference internal" href="#GLib.Cond.init" title="GLib.Cond.init"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.init</span></code></a>()
on it and <a class="reference internal" href="#GLib.Cond.clear" title="GLib.Cond.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.clear</span></code></a>() when done.</p>
<p>A <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> should only be accessed via the g_cond_ functions.</p>
<dl class="method">
<dt id="GLib.Cond.broadcast">
<code class="descname">broadcast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1558"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>If threads are waiting for <cite>self</cite>, all of them are unblocked.
If no threads are waiting for <cite>self</cite>, this function has no effect.
It is good practice to lock the same mutex as the waiting threads
while calling this function, though not required.</p>
</dd></dl>

<dl class="method">
<dt id="GLib.Cond.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1534"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees the resources allocated to a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> with <a class="reference internal" href="#GLib.Cond.init" title="GLib.Cond.init"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.init</span></code></a>().</p>
<p>This function should not be used with a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> that has been
statically allocated.</p>
<p>Calling <a class="reference internal" href="#GLib.Cond.clear" title="GLib.Cond.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.clear</span></code></a>() for a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> on which threads are
blocking leads to undefined behaviour.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.32.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="GLib.Cond.init">
<code class="descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1528"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> so that it can be used.</p>
<p>This function is useful to initialise a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> that has been
allocated as part of a larger structure.  It is not necessary to
initialise a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> that has been statically allocated.</p>
<p>To undo the effect of <a class="reference internal" href="#GLib.Cond.init" title="GLib.Cond.init"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.init</span></code></a>() when a <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> is no longer
needed, use <a class="reference internal" href="#GLib.Cond.clear" title="GLib.Cond.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.clear</span></code></a>().</p>
<p>Calling <a class="reference internal" href="#GLib.Cond.init" title="GLib.Cond.init"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.init</span></code></a>() on an already-initialised <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> leads
to undefined behaviour.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.32.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="GLib.Cond.signal">
<code class="descname">signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1550"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.signal" title="Permalink to this definition">¶</a></dt>
<dd><p>If threads are waiting for <cite>self</cite>, at least one of them is unblocked.
If no threads are waiting for <cite>self</cite>, this function has no effect.
It is good practice to hold the same lock as the waiting thread
while calling this function, though not required.</p>
</dd></dl>

<dl class="method">
<dt id="GLib.Cond.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>mutex</em><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1540"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.wait" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mutex</strong> (<a class="reference internal" href="Mutex.html#GLib.Mutex" title="GLib.Mutex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Mutex</span></code></a>) – a <a class="reference internal" href="Mutex.html#GLib.Mutex" title="GLib.Mutex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Mutex</span></code></a> that is currently locked</td>
</tr>
</tbody>
</table>
<p>Atomically releases <cite>mutex</cite> and waits until <cite>self</cite> is signalled.
When this function returns, <cite>mutex</cite> is locked again and owned by the
calling thread.</p>
<p>When using condition variables, it is possible that a spurious wakeup
may occur (ie: <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() returns even though <a class="reference internal" href="#GLib.Cond.signal" title="GLib.Cond.signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.signal</span></code></a>() was
not called).  It’s also possible that a stolen wakeup may occur.
This is when <a class="reference internal" href="#GLib.Cond.signal" title="GLib.Cond.signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.signal</span></code></a>() is called, but another thread acquires
<cite>mutex</cite> before this thread and modifies the state of the program in
such a way that when <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() is able to return, the expected
condition is no longer met.</p>
<p>For this reason, <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() must always be used in a loop.  See
the documentation for <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a> for a complete example.</p>
</dd></dl>

<dl class="method">
<dt id="GLib.Cond.wait_until">
<code class="descname">wait_until</code><span class="sig-paren">(</span><em>mutex</em>, <em>end_time</em><span class="sig-paren">)</span><a class="reference external" href="https://gitlab.gnome.org/GNOME/glib/blob/2.66.2/glib/gthread-posix.c#L1568"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#GLib.Cond.wait_until" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mutex</strong> (<a class="reference internal" href="Mutex.html#GLib.Mutex" title="GLib.Mutex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Mutex</span></code></a>) – a <a class="reference internal" href="Mutex.html#GLib.Mutex" title="GLib.Mutex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Mutex</span></code></a> that is currently locked</li>
<li><strong>end_time</strong> (<a class="reference external" href="http://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>) – the monotonic time to wait until</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><a class="reference external" href="http://docs.python.org/3/library/constants.html#True" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> on a signal, <a class="reference external" href="http://docs.python.org/3/library/constants.html#False" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a> on a timeout</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</td>
</tr>
</tbody>
</table>
<p>Waits until either <cite>self</cite> is signalled or <cite>end_time</cite> has passed.</p>
<p>As with <a class="reference internal" href="#GLib.Cond.wait" title="GLib.Cond.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond.wait</span></code></a>() it is possible that a spurious or stolen wakeup
could occur.  For that reason, waiting on a condition variable should
always be in a loop, based on an explicitly-checked predicate.</p>
<p><a class="reference external" href="http://docs.python.org/3/library/constants.html#True" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> is returned if the condition variable was signalled (or in the
case of a spurious wakeup).  <a class="reference external" href="http://docs.python.org/3/library/constants.html#False" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a> is returned if <cite>end_time</cite> has
passed.</p>
<p>The following code shows how to correctly perform a timed wait on a
condition variable (extending the example presented in the
documentation for <a class="reference internal" href="#GLib.Cond" title="GLib.Cond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GLib.Cond</span></code></a>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gpointer</span><span class="w"></span>
<span class="nf">pop_data_timed</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">gint64</span><span class="w"> </span><span class="n">end_time</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">gpointer</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">g_mutex_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">end_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_get_monotonic_time</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">G_TIME_SPAN_SECOND</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">current_data</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">g_cond_wait_until</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_cond</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">,</span><span class="w"> </span><span class="n">end_time</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// timeout has passed.</span>
<span class="w">        </span><span class="n">g_mutex_unlock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// there is data for us</span>
<span class="w">  </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">current_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">g_mutex_unlock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the end time is calculated once, before entering the
loop and reused.  This is the motivation behind the use of absolute
time on this API – if a relative time of 5 seconds were passed
directly to the call and a spurious wakeup occurred, the program would
have to start over waiting again (which would lead to a total wait
time of more than 5 seconds).</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.32.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>

    </section>

  </div> 

</body>
</html>